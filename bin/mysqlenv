#!perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/mysqlenv.pm"} = <<'APP_MYSQLENV';
  package App::mysqlenv;use 5.008001;use strict;use warnings;our$VERSION="0.01";our$DEBUG;sub debug {$DEBUG}1;
APP_MYSQLENV

$fatpacked{"App/mysqlenv/CLI.pm"} = <<'APP_MYSQLENV_CLI';
  package App::mysqlenv::CLI;use strict;use warnings;use App::mysqlenv;use App::mysqlenv::CLI::Init;use App::mysqlenv::CLI::Help;use App::mysqlenv::CLI::Available;use App::mysqlenv::CLI::Install;use App::mysqlenv::CLI::List;use App::mysqlenv::CLI::Global;use App::mysqlenv::CLI::Local;use App::mysqlenv::CLI::Rehash;use App::mysqlenv::CLI::Exec;use App::mysqlenv::CLI::Version;use App::mysqlenv::CLI::Which;use App::mysqlenv::Logger;use App::mysqlenv::Getopt;sub new {my$class=shift;bless {},$class}sub run {my ($self,@argv)=@_;@argv=@ARGV unless@argv;local$App::mysqlenv::DEBUG=0;local$App::mysqlenv::Logger::COLOR=-t STDOUT ? 1 : 0;my@commands;App::mysqlenv::Getopt->parse_options(\@argv=>('h|help'=>sub {unshift@commands,'help'},'debug!'=>\$App::mysqlenv::DEBUG,'color!'=>\$App::mysqlenv::Logger::COLOR,'V|version'=>\&show_version,),);push@commands,@argv;my$cmd=shift@commands || 'help';App::mysqlenv::Getopt->parse_options(\@commands,=>('h|help'=>sub {unshift@commands,$cmd;$cmd='help'},),);my$klass=sprintf 'App::mysqlenv::CLI::%s',join '',map {ucfirst $_}split '-',$cmd;unless (eval "require $klass; 1"){warnf("Could not find command '%s'\n",$cmd);exit 2}eval {$klass->run(@commands)};if (my$e=$@){unless (eval {$e->isa('App::mysqlenv::Exception')}){errorf("%s\n",$e)}exit 1}return 1}sub show_version {print "mysqlenv (App::mysqlenv) version $App::mysqlenv::VERSION\n";exit 0}1;
APP_MYSQLENV_CLI

$fatpacked{"App/mysqlenv/CLI/Available.pm"} = <<'APP_MYSQLENV_CLI_AVAILABLE';
  package App::mysqlenv::CLI::Available;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@argv)=@_;system 'mysql-build','--definitions' and die "$!";return 1}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::Available - List available mysql versions
  
  =head1 SYNOPSIS
  
      mysqlenv available
  
APP_MYSQLENV_CLI_AVAILABLE

$fatpacked{"App/mysqlenv/CLI/Exec.pm"} = <<'APP_MYSQLENV_CLI_EXEC';
  package App::mysqlenv::CLI::Exec;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@args)=@_;my$bin=shift@args || show_usage('exec');my$shims_path=shims_path;my ($version,$file)=detect_version;unless ($version){$ENV{PATH}=join ':',grep {canonpath($_)ne $shims_path}File::Spec->path}else {my$bindir=catdir install_home,$version,'bin';$ENV{PATH}=join ':',$bindir,$ENV{PATH}}unless (which$bin){errorf '[mysqlenv] command not found: %s',$bin}exec$bin,@args;die $!}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::Exec - Execute commands on current mysql environment
  
  =head1 SYNOPSIS
  
      mysqlenv exec <command> [arguments]
  
APP_MYSQLENV_CLI_EXEC

$fatpacked{"App/mysqlenv/CLI/Global.pm"} = <<'APP_MYSQLENV_CLI_GLOBAL';
  package App::mysqlenv::CLI::Global;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@argv)=@_;my$version_file=find_global_mysqlenv_version_file;my$global_version='';if ($version_file && -f $version_file){$global_version=slurp_version($version_file)}my$new_version=shift@argv;unless ($new_version || $global_version){show_usage('global')}if (!$new_version || $global_version eq $new_version){print "$global_version\n";exit}unless (-d catdir install_home,$new_version){errorf "$new_version was not found"}$version_file ||=catfile mysqlenv_home,'version';write_file$version_file,$new_version;return 1}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::Global - Change global mysql version
  
  =head1 SYNOPSIS
  
      mysqlenv global [version]
  
APP_MYSQLENV_CLI_GLOBAL

$fatpacked{"App/mysqlenv/CLI/Help.pm"} = <<'APP_MYSQLENV_CLI_HELP';
  package App::mysqlenv::CLI::Help;use strict;use warnings;use Pod::Usage qw(pod2usage);use App::mysqlenv::Logger;sub run {my ($class,$command)=@_;my$target=$0;my$verbose=2;if ($command){$command='help' if$command =~ m/^-?-h(?:epl)?$/;my$suffix=join '',map {ucfirst $_}split '-',$command;my$module="App::mysqlenv::CLI::$suffix";unless (eval "require $module; 1"){errorf '[mysqlenv] command not implemented: %s',$command}no strict 'refs';$target=\*{"$module\::DATA"};$verbose=1}pod2usage(-verbose=>$verbose,-input=>$target,)}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::Help - Provide help messages
  
  =head1 SYNOPSIS
  
      mysqlenv help
      mysqlenv help <command>
      mysqlenv <command> -h
      mysqlenv help -h
  
APP_MYSQLENV_CLI_HELP

$fatpacked{"App/mysqlenv/CLI/Init.pm"} = <<'APP_MYSQLENV_CLI_INIT';
  package App::mysqlenv::CLI::Init;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;my$MYSQLBUILD_REPOS='https://github.com/kamipo/mysql-build.git';sub run {my ($class,@args)=@_;my$home=mysqlenv_home;mkdir$home or errorf "$!: $home" unless -d $home;chdir$home or errorf "$!: $home";mkpath $_ for qw{bin mysqls etc shims};unless (-d 'mysql-build'){command 'git','clone',$MYSQLBUILD_REPOS,'mysql-build'}my$etc=catdir$home,'etc';chdir$etc or errorf "$!: $etc";for my$data (['bashrc'=>'_BASHRC_CONTENT' ],){my ($file,$method)=@$data;write_file$file,$class->$method or die "$!: $etc/$file"}print << "INSTRUCTION";return 1}sub _BASHRC_CONTENT {my$home=mysqlenv_home;return << "ERC"}1;
  
  mysqlenv is initialized ($home).
  
  Append the following piece of code to the end of your ~/.bashrc or ~/.zshrc
  and start a new shell.
  
      source ~/.mysqlenv/etc/bashrc
  
  Simply run `mysqlenv` for usage details.
  
  INSTRUCTION
  export PATH=$home/bin:$home/shims:$home/mysql-build/bin:\$PATH
  ERC
APP_MYSQLENV_CLI_INIT

$fatpacked{"App/mysqlenv/CLI/Install.pm"} = <<'APP_MYSQLENV_CLI_INSTALL';
  package App::mysqlenv::CLI::Install;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;use App::mysqlenv::Getopt;sub run {my ($class,@args)=@_;my$install_home=install_home;App::mysqlenv::Getopt->parse_options(\@args=>('v|verbose!'=>\my$verbose,'--as=s'=>\my$as,),);my$version=shift@args || show_usage('install');my$install_path=catdir$install_home,$as || $version;if (-d $install_path){errorf '%s is exists',$install_path}command 'mysql-build',($verbose ? '-v' : ()),$version,$install_path,(@args ? ('--',@args): ()),;chdir$install_path or die "$!: $install_path";command './scripts/mysql_install_db';infof 'Successfully install!';print << "NOTE";system $0,'rehash';return 1}1;__DATA__ 
  
  You can try
  
  \$ mysqlenv global $version
  
  NOTE
  =head1 NAME
  
  App::mysqlenv::CLI::Install - Build and install mysql binary
  
  =head1 SYNOPSIS
  
      mysqlenv install [options] <version> [arguments]
  
  =head1 OPTIONS
  
      -v, --verbose       Chatty build log.
          --as            Install the given version of MySQL by a name.
  
APP_MYSQLENV_CLI_INSTALL

$fatpacked{"App/mysqlenv/CLI/List.pm"} = <<'APP_MYSQLENV_CLI_LIST';
  package App::mysqlenv::CLI::List;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@argv)=@_;my$install_home=install_home;my ($current_version)=detect_version || '';chdir$install_home or die "$!: $install_home";opendir my$dh,'.' or die "$!: $install_home";for my$version (grep!/^\./ && -d,readdir$dh){if ($version eq $current_version){print "* $version\n"}else {print "  $version\n"}}return 1}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::List - List installed mysqls
  
  =head1 SYNOPSIS
  
      mysqlenv list
  
APP_MYSQLENV_CLI_LIST

$fatpacked{"App/mysqlenv/CLI/Local.pm"} = <<'APP_MYSQLENV_CLI_LOCAL';
  package App::mysqlenv::CLI::Local;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@args)=@_;App::mysqlenv::Getopt->parse_options(\@args=>('unset'=>\my$unset,),);if ($unset){if (my$file=find_lcoal_mysqlenv_version_file){unlink$file}else {errorf '[mysqlenv] no local version configured for this directory'}}else {my$version=shift@args;if ($version){unless (-d catfile install_home,$version){errorf '[mysqlenv] %s is not installed',$version}write_file '.mysql-version',$version}else {if (my$file=find_lcoal_mysqlenv_version_file){print slurp_version($file),"\n"}else {errorf '[mysqlenv] no local version configured for this directory'}}}return 1}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::SelfInstall - Setes local mysql version under the directory
  
  =head1 SYNOPSIS
  
      mysqlenv local [options] [version]
  
  =head1 OPTIONS
  
      --unset     Unset the local version.
  
APP_MYSQLENV_CLI_LOCAL

$fatpacked{"App/mysqlenv/CLI/Rehash.pm"} = <<'APP_MYSQLENV_CLI_REHASH';
  package App::mysqlenv::CLI::Rehash;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@argv)=@_;my$mysqlenv_home=mysqlenv_home;my$install_home=install_home;my$shims=catdir mysqlenv_home,'shims';my%seen;for my$bin (map {basename $_}grep {-x $_}glob("$install_home/*/bin/*")){next if$seen{$bin}++;my$shimbin=catfile$shims,$bin;my$cmd=sprintf q{exec "%s" exec "$program" "$@"},rel2abs($0);write_file$shimbin,sprintf(<<'...',$mysqlenv_home,$cmd);chmod 0755,$shimbin or die "$!: $shimbin"}return 1}1;__DATA__ 
  #!/usr/bin/env bash
  set -e
  [ -n "$MYSQLENV_DEBUG" ] && set -x
  
  program="${0##*/}"
  
  export MYSQLENV_HOME="%s"
  %s
  ...
  =head1 NAME
  
  App::mysqlenv::CLI::Rehash - Run this command after install, contains executable script.
  
  =head1 SYNOPSIS
  
      mysqlenv rehash
  
APP_MYSQLENV_CLI_REHASH

$fatpacked{"App/mysqlenv/CLI/SelfInstall.pm"} = <<'APP_MYSQLENV_CLI_SELFINSTALL';
  package App::mysqlenv::CLI::SelfInstall;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@args)=@_;my$bindir=catdir mysqlenv_home,'bin';unless (-d $bindir){mkpath$bindir or die "$!: $bindir"}my$target=catfile$bindir,'mysqlenv';my@lines=read_file $0 or die "$!: $0";$lines[0]='#!/usr/bin/env perl';write_file$target,@lines or die "$!: $target";chmod 0755,$target or die "$!: $target";system$target,'init'}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::SelfInstall - Install mysqlenv itself $MYSQLENV_HOME/bin
  
  =head1 SYNOPSIS
  
      mysqlenv self-install
  
APP_MYSQLENV_CLI_SELFINSTALL

$fatpacked{"App/mysqlenv/CLI/Version.pm"} = <<'APP_MYSQLENV_CLI_VERSION';
  package App::mysqlenv::CLI::Version;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@argv)=@_;my ($current_version,$file)=detect_version;unless ($current_version){errorf '[mysqlenv] Could not detect mysql version.'}print "$current_version (set by $file)\n";return 1}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::Version - Show current mysql version
  
  =head1 SYNOPSIS
  
      mysqlenv version
  
APP_MYSQLENV_CLI_VERSION

$fatpacked{"App/mysqlenv/CLI/Which.pm"} = <<'APP_MYSQLENV_CLI_WHICH';
  package App::mysqlenv::CLI::Which;use strict;use warnings;use App::mysqlenv::Util;use App::mysqlenv::Logger;sub run {my ($class,@argv)=@_;my$bin=shift@argv || show_usage('which');my ($version,$file)=detect_version();my$shims_path=shims_path;my@path=grep {canonpath($_)ne $shims_path}File::Spec->path;unshift@path,bin_path$version if$version;if (my$fullpath=which$bin,@path){print "$fullpath\n"}else {errorf '[mysqlenv] command not found: %s',$bin}return 1}1;__DATA__ 
  =head1 NAME
  
  App::mysqlenv::CLI::Which - Locate a program file int the mysqlenv's path
  
  =head1 SYNOPSIS
  
      mysqlenv which <command>
  
APP_MYSQLENV_CLI_WHICH

$fatpacked{"App/mysqlenv/Exception.pm"} = <<'APP_MYSQLENV_EXCEPTION';
  package App::mysqlenv::Exception;use strict;use warnings;use overload '""'=>'to_string',fallback=>1;use Carp qw();sub throw {my$class=shift;my$self=bless {msg=>Carp::longmess($class)},$class;die$self}sub to_string {my$self=shift;$self->{msg}}1;
APP_MYSQLENV_EXCEPTION

$fatpacked{"App/mysqlenv/Getopt.pm"} = <<'APP_MYSQLENV_GETOPT';
  package App::mysqlenv::Getopt;use strict;use warnings;use Getopt::Long;sub parse_options {my ($class,$argv,@options)=@_;my$parser=Getopt::Long::Parser->new(config=>[qw{posix_default no_ignore_case gnu_compat pass_through}],);$parser->getoptionsfromarray($argv=>@options)or return;return$argv}1;
APP_MYSQLENV_GETOPT

$fatpacked{"App/mysqlenv/Logger.pm"} = <<'APP_MYSQLENV_LOGGER';
  package App::mysqlenv::Logger;use strict;use warnings;use parent 'Exporter';use Term::ANSIColor qw(colored);use App::mysqlenv::Exception;our@EXPORT=qw{debugf infof warnf errorf};our$COLOR;use constant {DEBUG=>1,INFO=>2,WARN=>3,ERROR=>4,};our$Colors={DEBUG,=>'green',INFO,=>'cyan',WARN,=>'yellow',ERROR,=>'red',};sub _print {my($msg,$type)=@_;return if$type==DEBUG &&!App::mysqlenv->debug;$msg=colored$msg,$Colors->{$type}if defined$type && $COLOR;my$fh=$type && $type >= WARN ? *STDERR : *STDOUT;print {$fh}$msg,"\n"}sub _printf {my$type=pop;my($temp,@args)=@_;_print sprintf($temp,map {defined $_ ? $_ : '-'}@args),$type}sub debugf {_printf @_,DEBUG}sub infof {_printf @_,INFO}sub warnf {_printf @_,WARN}sub errorf {_printf @_,ERROR;App::mysqlenv::Exception->throw}1;
APP_MYSQLENV_LOGGER

$fatpacked{"App/mysqlenv/Util.pm"} = <<'APP_MYSQLENV_UTIL';
  package App::mysqlenv::Util;use strict;use warnings;use parent 'Exporter';use Cwd qw(getcwd);use File::Basename qw(basename dirname);use File::Path qw(mkpath rmtree);use File::Spec::Functions qw(catdir catfile canonpath rel2abs);use File::Slurp qw(write_file read_file);use App::mysqlenv::Logger;our@EXPORT=qw{mkpath rmtree catdir catfile rel2abs canonpath basename dirname getcwd write_file read_file command mysqlenv_home install_home shims_path bin_path detect_version find_mysqlenv_version_file find_lcoal_mysqlenv_version_file find_global_mysqlenv_version_file slurp_version show_usage which};sub mysqlenv_home {my$home;if ($ENV{MYSQLENV_HOME}){$home=$ENV{MYSQLENV_HOME}}elsif ($ENV{HOME}){$home=catdir$ENV{HOME},'.mysqlenv';$ENV{MYSQLENV_HOME}=$home}else {die "There is no ENV[MYSQLENV_HOME] or ENV[HOME]. Please set ENV[MYSQLENV_HOME].\n"}$ENV{MYSQLENV_HOME}=canonpath$home}sub install_home {canonpath catdir mysqlenv_home(),'mysqls'}sub shims_path {canonpath catdir mysqlenv_home,'shims'}sub bin_path {my$version=shift;canonpath catdir install_home,$version,'bin'}sub which {my ($bin,@path)=@_;@path=File::Spec->path unless@path;for my$dir (@path){my$fullpath=catfile$dir,$bin;next unless -x $fullpath;return$fullpath}return undef}sub detect_version {return$ENV{MYSQLENV_VERSION}if$ENV{MYSQLENV_VERSION};if (my$file=find_mysqlenv_version_file()){my$version=slurp_version($file);return ($version,$file)}return undef}sub find_mysqlenv_version_file {find_lcoal_mysqlenv_version_file()|| find_global_mysqlenv_version_file()}sub find_lcoal_mysqlenv_version_file {my$dir=getcwd();my%seen;while (-d $dir){return undef if$seen{$dir}++;if (-f "$dir/.mysql-version"){return "$dir/.mysql-version"}$dir=dirname$dir}return undef}sub find_global_mysqlenv_version_file {my$mysqlenv_version_file=catfile mysqlenv_home(),'version';return$mysqlenv_version_file if -f $mysqlenv_version_file;return undef}sub slurp_version {my$file=shift;return unless -f $file;my ($version)=read_file$file or die "$!: $file";return$version}sub command {my@commands=@_;infof 'run: %s',join ' ',@_;!system(@_)or die "$?"}sub show_usage {require App::mysqlenv::CLI::Help;App::mysqlenv::CLI::Help->run(@_);exit 1}1;
APP_MYSQLENV_UTIL

$fatpacked{"File/Path.pm"} = <<'FILE_PATH';
  package File::Path;use 5.005_04;use strict;use Cwd 'getcwd';use File::Basename ();use File::Spec ();BEGIN {if ($] < 5.006){eval "use Symbol"}}use Exporter ();use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);$VERSION='2.09';@ISA=qw(Exporter);@EXPORT=qw(mkpath rmtree);@EXPORT_OK=qw(make_path remove_tree);my$Is_VMS=$^O eq 'VMS';my$Is_MacOS=$^O eq 'MacOS';my$Force_Writeable=grep {$^O eq $_}qw(amigaos dos epoc MSWin32 MacOS os2);my$Need_Stat_Check=!($^O eq 'MSWin32');sub _carp {require Carp;goto&Carp::carp}sub _croak {require Carp;goto&Carp::croak}sub _error {my$arg=shift;my$message=shift;my$object=shift;if ($arg->{error}){$object='' unless defined$object;$message .= ": $!" if $!;push @{${$arg->{error}}},{$object=>$message}}else {_carp(defined($object)? "$message for $object: $!" : "$message: $!")}}sub make_path {push @_,{}unless @_ and UNIVERSAL::isa($_[-1],'HASH');goto&mkpath}sub mkpath {my$old_style=!(@_ and UNIVERSAL::isa($_[-1],'HASH'));my$arg;my$paths;if ($old_style){my ($verbose,$mode);($paths,$verbose,$mode)=@_;$paths=[$paths]unless UNIVERSAL::isa($paths,'ARRAY');$arg->{verbose}=$verbose;$arg->{mode}=defined$mode ? $mode : 0777}else {$arg=pop @_;$arg->{mode}=delete$arg->{mask}if exists$arg->{mask};$arg->{mode}=0777 unless exists$arg->{mode};${$arg->{error}}=[]if exists$arg->{error};$arg->{owner}=delete$arg->{user}if exists$arg->{user};$arg->{owner}=delete$arg->{uid}if exists$arg->{uid};if (exists$arg->{owner}and $arg->{owner}=~ /\D/){my$uid=(getpwnam$arg->{owner})[2];if (defined$uid){$arg->{owner}=$uid}else {_error($arg,"unable to map $arg->{owner} to a uid, ownership not changed");delete$arg->{owner}}}if (exists$arg->{group}and $arg->{group}=~ /\D/){my$gid=(getgrnam$arg->{group})[2];if (defined$gid){$arg->{group}=$gid}else {_error($arg,"unable to map $arg->{group} to a gid, group ownership not changed");delete$arg->{group}}}if (exists$arg->{owner}and not exists$arg->{group}){$arg->{group}=-1}if (exists$arg->{group}and not exists$arg->{owner}){$arg->{owner}=-1}$paths=[@_]}return _mkpath($arg,$paths)}sub _mkpath {my$arg=shift;my$paths=shift;my(@created,$path);for$path (@$paths){next unless defined($path)and length($path);$path .= '/' if $^O eq 'os2' and $path =~ /^\w:\z/s;if ($Is_VMS){next if$path eq '/';$path=VMS::Filespec::unixify($path)}next if -d $path;my$parent=File::Basename::dirname($path);unless (-d $parent or $path eq $parent){push(@created,_mkpath($arg,[$parent]))}print "mkdir $path\n" if$arg->{verbose};if (mkdir($path,$arg->{mode})){push(@created,$path);if (exists$arg->{owner}){if (!chown$arg->{owner},$arg->{group},$path){_error($arg,"Cannot change ownership of $path to $arg->{owner}:$arg->{group}")}}}else {my$save_bang=$!;my ($e,$e1)=($save_bang,$^E);$e .= "; $e1" if$e ne $e1;if (!-d $path){$!=$save_bang;if ($arg->{error}){push @{${$arg->{error}}},{$path=>$e}}else {_croak("mkdir $path: $e")}}}}return@created}sub remove_tree {push @_,{}unless @_ and UNIVERSAL::isa($_[-1],'HASH');goto&rmtree}sub _is_subdir {my($dir,$test)=@_;my($dv,$dd)=File::Spec->splitpath($dir,1);my($tv,$td)=File::Spec->splitpath($test,1);return 0 if$dv ne $tv;my@d=File::Spec->splitdir($dd);my@t=File::Spec->splitdir($td);return 0 if@t < @d;return join('/',@d)eq join('/',splice@t,0,+@d)}sub rmtree {my$old_style=!(@_ and UNIVERSAL::isa($_[-1],'HASH'));my$arg;my$paths;if ($old_style){my ($verbose,$safe);($paths,$verbose,$safe)=@_;$arg->{verbose}=$verbose;$arg->{safe}=defined$safe ? $safe : 0;if (defined($paths)and length($paths)){$paths=[$paths]unless UNIVERSAL::isa($paths,'ARRAY')}else {_carp ("No root path(s) specified\n");return 0}}else {$arg=pop @_;${$arg->{error}}=[]if exists$arg->{error};${$arg->{result}}=[]if exists$arg->{result};$paths=[@_]}$arg->{prefix}='';$arg->{depth}=0;my@clean_path;$arg->{cwd}=getcwd()or do {_error($arg,"cannot fetch initial working directory");return 0};for ($arg->{cwd}){/\A(.*)\Z/;$_=$1}for my$p (@$paths){my$ortho_root=$^O eq 'MSWin32' ? _slash_lc($p): $p;my$ortho_cwd=$^O eq 'MSWin32' ? _slash_lc($arg->{cwd}): $arg->{cwd};my$ortho_root_length=length($ortho_root);$ortho_root_length-- if $^O eq 'VMS';if ($ortho_root_length && _is_subdir($ortho_root,$ortho_cwd)){local $!=0;_error($arg,"cannot remove path when cwd is $arg->{cwd}",$p);next}if ($Is_MacOS){$p=":$p" unless$p =~ /:/;$p .= ":" unless$p =~ /:\z/}elsif ($^O eq 'MSWin32'){$p =~ s{[/\\]\z}{}}else {$p =~ s{/\z}{}}push@clean_path,$p}@{$arg}{qw(device inode perm)}=(lstat$arg->{cwd})[0,1]or do {_error($arg,"cannot stat initial working directory",$arg->{cwd});return 0};return _rmtree($arg,\@clean_path)}sub _rmtree {my$arg=shift;my$paths=shift;my$count=0;my$curdir=File::Spec->curdir();my$updir=File::Spec->updir();my (@files,$root);ROOT_DIR: foreach$root (@$paths){my$canon=$arg->{prefix}? File::Spec->catfile($arg->{prefix},$root): $root ;my ($ldev,$lino,$perm)=(lstat$root)[0,1,2]or next ROOT_DIR;if (-d _){$root=VMS::Filespec::vmspath(VMS::Filespec::pathify($root))if$Is_VMS;if (!chdir($root)){$perm &=07777;my$nperm=$perm | 0700;if (!($arg->{safe}or $nperm==$perm or chmod($nperm,$root))){_error($arg,"cannot make child directory read-write-exec",$canon);next ROOT_DIR}elsif (!chdir($root)){_error($arg,"cannot chdir to child",$canon);next ROOT_DIR}}my ($cur_dev,$cur_inode,$perm)=(stat$curdir)[0,1,2]or do {_error($arg,"cannot stat current working directory",$canon);next ROOT_DIR};if ($Need_Stat_Check){($ldev eq $cur_dev and $lino eq $cur_inode)or _croak("directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.")}$perm &=07777;my$nperm=$perm | 0700;if (!($arg->{safe}or $nperm==$perm or chmod($nperm,$curdir))){_error($arg,"cannot make directory read+writeable",$canon);$nperm=$perm}my$d;$d=gensym()if $] < 5.006;if (!opendir$d,$curdir){_error($arg,"cannot opendir",$canon);@files=()}else {no strict 'refs';if (!defined ${"\cTAINT"}or ${"\cTAINT"}){@files=map {/\A(.*)\z/s;$1}readdir$d}else {@files=readdir$d}closedir$d}if ($Is_VMS){@files=map {$_ eq '.' ? '.;' : $_}reverse@files}@files=grep {$_ ne $updir and $_ ne $curdir}@files;if (@files){my$narg={%$arg};@{$narg}{qw(device inode cwd prefix depth)}=($cur_dev,$cur_inode,$updir,$canon,$arg->{depth}+1);$count += _rmtree($narg,\@files)}if ($nperm!=$perm and not chmod($perm,$curdir)){_error($arg,"cannot reset chmod",$canon)}chdir($arg->{cwd})or _croak("cannot chdir to $arg->{cwd} from $canon: $!, aborting.");($cur_dev,$cur_inode)=(stat$curdir)[0,1]or _croak("cannot stat prior working directory $arg->{cwd}: $!, aborting.");if ($Need_Stat_Check){($arg->{device}eq $cur_dev and $arg->{inode}eq $cur_inode)or _croak("previous directory $arg->{cwd} changed before entering $canon, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.")}if ($arg->{depth}or!$arg->{keep_root}){if ($arg->{safe}&& ($Is_VMS ?!&VMS::Filespec::candelete($root):!-w $root)){print "skipped $root\n" if$arg->{verbose};next ROOT_DIR}if ($Force_Writeable and!chmod$perm | 0700,$root){_error($arg,"cannot make directory writeable",$canon)}print "rmdir $root\n" if$arg->{verbose};if (rmdir$root){push @{${$arg->{result}}},$root if$arg->{result};++$count}else {_error($arg,"cannot remove directory",$canon);if ($Force_Writeable &&!chmod($perm,($Is_VMS ? VMS::Filespec::fileify($root): $root))){_error($arg,sprintf("cannot restore permissions to 0%o",$perm),$canon)}}}}else {$root=VMS::Filespec::vmsify("./$root")if$Is_VMS &&!File::Spec->file_name_is_absolute($root)&& ($root !~ m/(?<!\^)[\]>]+/);if ($arg->{safe}&& ($Is_VMS ?!&VMS::Filespec::candelete($root):!(-l $root || -w $root))){print "skipped $root\n" if$arg->{verbose};next ROOT_DIR}my$nperm=$perm & 07777 | 0600;if ($Force_Writeable and $nperm!=$perm and not chmod$nperm,$root){_error($arg,"cannot make file writeable",$canon)}print "unlink $canon\n" if$arg->{verbose};for (;;){if (unlink$root){push @{${$arg->{result}}},$root if$arg->{result}}else {_error($arg,"cannot unlink file",$canon);$Force_Writeable and chmod($perm,$root)or _error($arg,sprintf("cannot restore permissions to 0%o",$perm),$canon);last}++$count;last unless$Is_VMS && lstat$root}}}return$count}sub _slash_lc {my$path=shift;$path =~ tr{\\}{/};return lc($path)}1;
FILE_PATH

$fatpacked{"File/Slurp.pm"} = <<'FILE_SLURP';
  package File::Slurp;use 5.6.2 ;use strict;use warnings ;use Carp ;use Exporter ;use Fcntl qw(:DEFAULT) ;use POSIX qw(:fcntl_h) ;use Errno ;use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION) ;@ISA=qw(Exporter) ;$VERSION='9999.19';my@std_export=qw(read_file write_file overwrite_file append_file read_dir) ;my@edit_export=qw(edit_file edit_file_lines) ;my@ok_export=qw() ;@EXPORT_OK=(@edit_export,qw(slurp prepend_file),);%EXPORT_TAGS=('all'=>[@std_export,@edit_export,@EXPORT_OK ],'edit'=>[@edit_export ],'std'=>[@std_export ],);@EXPORT=@std_export ;my$max_fast_slurp_size=1024 * 100 ;my$is_win32=$^O =~ /win32/i ;BEGIN {unless(defined&SEEK_SET){*SEEK_SET=sub {0};*SEEK_CUR=sub {1};*SEEK_END=sub {2}}unless(defined&O_BINARY){*O_BINARY=sub {0};*O_RDONLY=sub {0};*O_WRONLY=sub {1}}unless (defined&O_APPEND){if ($^O =~ /olaris/){*O_APPEND=sub {8};*O_CREAT=sub {256};*O_EXCL=sub {1024}}elsif ($^O =~ /inux/){*O_APPEND=sub {1024};*O_CREAT=sub {64};*O_EXCL=sub {128}}elsif ($^O =~ /BSD/i){*O_APPEND=sub {8};*O_CREAT=sub {512};*O_EXCL=sub {2048}}}}*slurp=\&read_file ;sub read_file {my$file_name=shift ;my$opts=(ref $_[0]eq 'HASH')? shift : {@_};if (!ref$file_name && -e $file_name && -s _ > 0 && -s _ < $max_fast_slurp_size &&!%{$opts}&&!wantarray){my$fh ;unless(sysopen($fh,$file_name,O_RDONLY)){@_=($opts,"read_file '$file_name' - sysopen: $!");goto&_error }my$read_cnt=sysread($fh,my$buf,-s _);unless (defined$read_cnt){@_=($opts,"read_file '$file_name' - small sysread: $!");goto&_error }$buf =~ s/\015\012/\n/g if$is_win32 ;return$buf }my$buf ;my$buf_ref=$opts->{'buf_ref'}|| \$buf ;${$buf_ref}='' ;my($read_fh,$size_left,$blk_size);if (ref$file_name){my$ref_result=_check_ref($file_name);if (ref$ref_result){@_=($opts,$ref_result);goto&_error }if ($ref_result){$file_name=$ref_result }else {$read_fh=$file_name ;$blk_size=$opts->{'blk_size'}|| 1024 * 1024 ;$size_left=$blk_size }}unless ($read_fh){my$mode=O_RDONLY ;$read_fh=local(*FH);unless (sysopen($read_fh,$file_name,$mode)){@_=($opts,"read_file '$file_name' - sysopen: $!");goto&_error }if (my$binmode=$opts->{'binmode'}){binmode($read_fh,$binmode)}$size_left=-s $read_fh ;unless($size_left){$blk_size=$opts->{'blk_size'}|| 1024 * 1024 ;$size_left=$blk_size }}while(1){my$read_cnt=sysread($read_fh,${$buf_ref},$size_left,length ${$buf_ref});next if $!{EINTR};unless (defined$read_cnt){@_=($opts,"read_file '$file_name' - loop sysread: $!");goto&_error }last if$read_cnt==0 ;next if$blk_size ;$size_left -= $read_cnt ;last if$size_left <= 0 }${$buf_ref}=~ s/\015\012/\n/g if$is_win32 &&!$opts->{'binmode'};my$sep=$/ ;$sep='\n\n+' if defined$sep && $sep eq '' ;if(wantarray || $opts->{'array_ref'}){use re 'taint' ;my@lines=length(${$buf_ref})? ${$buf_ref}=~ /(.*?$sep|.+)/sg : ();chomp@lines if$opts->{'chomp'};return \@lines if$opts->{'array_ref'};return@lines }return$buf_ref if$opts->{'scalar_ref'};return ${$buf_ref}if defined wantarray ;return }sub _check_ref {my($handle)=@_ ;if (eval {$handle->isa('GLOB')|| $handle->isa('IO')}){my$err=_seek_data_handle($handle);return \$err if$err ;return }eval {require overload};return \"Bad handle '$handle' is not a GLOB or IO object or overloaded" if $@ ||!overload::Overloaded($handle);return "$handle" }sub _seek_data_handle {my($handle)=@_ ;eval{require B};if ($@){return <<ERR }if (B::svref_2object($handle)->IO->IoFLAGS & 16){unless(sysseek($handle,tell($handle),SEEK_SET)){return "read_file '$handle' - sysseek: $!" }}return }sub write_file {my$file_name=shift ;my$opts=(ref $_[0]eq 'HASH')? shift : {};my($buf_ref,$write_fh,$no_truncate,$orig_file_name,$data_is_ref);if (ref$opts->{'buf_ref'}eq 'SCALAR'){$buf_ref=$opts->{'buf_ref'};$data_is_ref=1 }elsif (ref $_[0]eq 'SCALAR'){$buf_ref=shift ;$data_is_ref=1 }elsif (ref $_[0]eq 'ARRAY'){${$buf_ref}=join '',@{$_[0]}}else {${$buf_ref}=join '',@_ }if (ref$file_name){my$ref_result=_check_ref($file_name);if (ref$ref_result){@_=($opts,$ref_result);goto&_error }if ($ref_result){$file_name=$ref_result }else {$write_fh=$file_name ;$no_truncate=1 }}unless($write_fh){if ($opts->{'atomic'}){$orig_file_name=$file_name ;$file_name .= ".$$" }my$mode=O_WRONLY | O_CREAT ;$mode |=O_APPEND if$opts->{'append'};$mode |=O_EXCL if$opts->{'no_clobber'};my$perms=$opts->{perms};$perms=0666 unless defined$perms ;$write_fh=local(*FH);unless (sysopen($write_fh,$file_name,$mode,$perms)){@_=($opts,"write_file '$file_name' - sysopen: $!");goto&_error }}if (my$binmode=$opts->{'binmode'}){binmode($write_fh,$binmode)}sysseek($write_fh,0,SEEK_END)if$opts->{'append'};if ($is_win32 &&!$opts->{'binmode'}){$buf_ref=\do{my$copy=${$buf_ref}}if$data_is_ref ;${$buf_ref}=~ s/\n/\015\012/g }my$size_left=length(${$buf_ref});my$offset=0 ;do {my$write_cnt=syswrite($write_fh,${$buf_ref},$size_left,$offset);next if $!{EINTR};unless (defined$write_cnt){@_=($opts,"write_file '$file_name' - syswrite: $!");goto&_error }$size_left -= $write_cnt ;$offset += $write_cnt }while($size_left > 0);truncate($write_fh,sysseek($write_fh,0,SEEK_CUR))unless$no_truncate ;close($write_fh);if ($opts->{'atomic'}&&!rename($file_name,$orig_file_name)){@_=($opts,"write_file '$file_name' - rename: $!");goto&_error }return 1 }*overwrite_file=\&write_file ;sub append_file {my$opts=$_[1];if (ref$opts eq 'HASH'){$opts->{append}=1 }else {splice(@_,1,0,{append=>1 })}goto&write_file}sub prepend_file {my$file_name=shift ;my$opts=(ref $_[0]eq 'HASH')? shift : {};my@bad_opts=grep $_ ne 'err_mode' && $_ ne 'binmode',keys %{$opts};delete @{$opts}{@bad_opts};my$prepend_data=shift ;$prepend_data='' unless defined$prepend_data ;$prepend_data=${$prepend_data}if ref$prepend_data eq 'SCALAR' ;my$err_mode=delete$opts->{err_mode};$opts->{err_mode }='croak' ;$opts->{scalar_ref }=1 ;my$existing_data=eval {read_file($file_name,$opts)};if ($@){@_=({err_mode=>$err_mode },"prepend_file '$file_name' - read_file: $!");goto&_error }$opts->{atomic}=1 ;my$write_result=eval {write_file($file_name,$opts,$prepend_data,$$existing_data)};if ($@){@_=({err_mode=>$err_mode },"prepend_file '$file_name' - write_file: $!");goto&_error }return$write_result }sub edit_file(&$;$) {my($edit_code,$file_name,$opts)=@_ ;$opts={}unless ref$opts eq 'HASH' ;my@bad_opts=grep $_ ne 'err_mode' && $_ ne 'binmode',keys %{$opts};delete @{$opts}{@bad_opts};my$err_mode=delete$opts->{err_mode};$opts->{err_mode }='croak' ;$opts->{scalar_ref }=1 ;my$existing_data=eval {read_file($file_name,$opts)};if ($@){@_=({err_mode=>$err_mode },"edit_file '$file_name' - read_file: $!");goto&_error }my($edited_data)=map {$edit_code->();$_}$$existing_data ;$opts->{atomic}=1 ;my$write_result=eval {write_file($file_name,$opts,$edited_data)};if ($@){@_=({err_mode=>$err_mode },"edit_file '$file_name' - write_file: $!");goto&_error }return$write_result }sub edit_file_lines(&$;$) {my($edit_code,$file_name,$opts)=@_ ;$opts={}unless ref$opts eq 'HASH' ;my@bad_opts=grep $_ ne 'err_mode' && $_ ne 'binmode',keys %{$opts};delete @{$opts}{@bad_opts};my$err_mode=delete$opts->{err_mode};$opts->{err_mode }='croak' ;$opts->{array_ref }=1 ;my$existing_data=eval {read_file($file_name,$opts)};if ($@){@_=({err_mode=>$err_mode },"edit_file_lines '$file_name' - read_file: $!");goto&_error }my@edited_data=map {$edit_code->();$_}@$existing_data ;$opts->{atomic}=1 ;my$write_result=eval {write_file($file_name,$opts,@edited_data)};if ($@){@_=({err_mode=>$err_mode },"edit_file_lines '$file_name' - write_file: $!");goto&_error }return$write_result }sub read_dir {my$dir=shift ;my$opts=(ref $_[0]eq 'HASH')? shift : {@_};local(*DIRH);unless (opendir(DIRH,$dir)){@_=($opts,"read_dir '$dir' - opendir: $!");goto&_error }my@dir_entries=readdir(DIRH);@dir_entries=grep($_ ne "." && $_ ne "..",@dir_entries)unless$opts->{'keep_dot_dot'};if ($opts->{'prefix'}){substr($_,0,0,"$dir/")for@dir_entries }return@dir_entries if wantarray ;return \@dir_entries }my%err_func=('carp'=>\&carp,'croak'=>\&croak,);sub _error {my($opts,$err_msg)=@_ ;my$func=$err_func{$opts->{'err_mode'}|| 'croak' };return unless$func ;$func->($err_msg)if$func ;return undef }1;
  Can't find B.pm with this Perl: $!.
  That module is needed to properly slurp the DATA handle.
  ERR
FILE_SLURP

$fatpacked{"Getopt/Long.pm"} = <<'GETOPT_LONG';
  package Getopt::Long;use 5.004;use strict;use vars qw($VERSION);$VERSION=2.39;use vars qw($VERSION_STRING);$VERSION_STRING="2.39";use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK);@ISA=qw(Exporter);sub GetOptions(@);sub GetOptionsFromArray(@);sub GetOptionsFromString(@);sub Configure(@);sub HelpMessage(@);sub VersionMessage(@);BEGIN {@EXPORT=qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);@EXPORT_OK=qw(&HelpMessage &VersionMessage &Configure &GetOptionsFromArray &GetOptionsFromString)}use vars@EXPORT,@EXPORT_OK;use vars qw($error $debug $major_version $minor_version);use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order $passthrough);use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);sub config(@);sub ConfigDefaults();sub ParseOptionSpec($$);sub OptCtl($);sub FindOption($$$$$);sub ValidValue ($$$$$);my$requested_version=0;sub ConfigDefaults() {if (defined$ENV{"POSIXLY_CORRECT"}){$genprefix="(--|-)";$autoabbrev=0;$bundling=0;$getopt_compat=0;$order=$REQUIRE_ORDER}else {$genprefix="(--|-|\\+)";$autoabbrev=1;$bundling=0;$getopt_compat=1;$order=$PERMUTE}$debug=0;$error=0;$ignorecase=1;$passthrough=0;$gnu_compat=0;$longprefix="(--)"}sub import {my$pkg=shift;my@syms=();my@config=();my$dest=\@syms;for (@_){if ($_ eq ':config'){$dest=\@config;next}push(@$dest,$_)}local$Exporter::ExportLevel=1;push(@syms,qw(&GetOptions))if@syms;$requested_version=0;$pkg->SUPER::import(@syms);Configure(@config)if@config}($REQUIRE_ORDER,$PERMUTE,$RETURN_IN_ORDER)=(0..2);($major_version,$minor_version)=$VERSION =~ /^(\d+)\.(\d+)/;ConfigDefaults();package Getopt::Long::Parser;my$default_config=do {Getopt::Long::Configure ()};sub new {my$that=shift;my$class=ref($that)|| $that;my%atts=@_;my$self={caller_pkg=>(caller)[0]};bless ($self,$class);if (defined$atts{config}){my$save=Getopt::Long::Configure ($default_config,@{$atts{config}});$self->{settings}=Getopt::Long::Configure ($save);delete ($atts{config})}else {$self->{settings}=$default_config}if (%atts){die(__PACKAGE__.": unhandled attributes: ".join(" ",sort(keys(%atts)))."\n")}$self}sub configure {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings},@_);$self->{settings}=Getopt::Long::Configure ($save)}sub getoptions {my ($self)=shift;return$self->getoptionsfromarray(\@ARGV,@_)}sub getoptionsfromarray {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings});my$ret=0;$Getopt::Long::caller=$self->{caller_pkg};eval {local ($SIG{__DIE__})='DEFAULT';$ret=Getopt::Long::GetOptionsFromArray (@_)};Getopt::Long::Configure ($save);die ($@)if $@;return$ret}package Getopt::Long;use constant CTL_TYPE=>0;use constant CTL_CNAME=>1;use constant CTL_DEFAULT=>2;use constant CTL_DEST=>3;use constant CTL_DEST_SCALAR=>0;use constant CTL_DEST_ARRAY=>1;use constant CTL_DEST_HASH=>2;use constant CTL_DEST_CODE=>3;use constant CTL_AMIN=>4;use constant CTL_AMAX=>5;use constant PAT_INT=>"[-+]?_*[0-9][0-9_]*";use constant PAT_XINT=>"(?:"."[-+]?_*[1-9][0-9_]*"."|"."0x_*[0-9a-f][0-9a-f_]*"."|"."0b_*[01][01_]*"."|"."0[0-7_]*".")";use constant PAT_FLOAT=>"[-+]?[0-9._]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";sub GetOptions(@) {unshift(@_,\@ARGV);goto&GetOptionsFromArray}sub GetOptionsFromString(@) {my ($string)=shift;require Text::ParseWords;my$args=[Text::ParseWords::shellwords($string)];$caller ||=(caller)[0];my$ret=GetOptionsFromArray($args,@_);return ($ret,$args)if wantarray;if (@$args){$ret=0;warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n")}$ret}sub GetOptionsFromArray(@) {my ($argv,@optionlist)=@_;my$argend='--';my%opctl=();my$pkg=$caller || (caller)[0];my@ret=();my%linkage;my$userlinkage;my$opt;my$prefix=$genprefix;$error='';if ($debug){local ($^W)=0;print STDERR ("Getopt::Long $Getopt::Long::VERSION ","called from package \"$pkg\".","\n  ","argv: (@$argv)","\n  ","autoabbrev=$autoabbrev,"."bundling=$bundling,","getopt_compat=$getopt_compat,","gnu_compat=$gnu_compat,","order=$order,","\n  ","ignorecase=$ignorecase,","requested_version=$requested_version,","passthrough=$passthrough,","genprefix=\"$genprefix\",","longprefix=\"$longprefix\".","\n")}$userlinkage=undef;if (@optionlist && ref($optionlist[0])and UNIVERSAL::isa($optionlist[0],'HASH')){$userlinkage=shift (@optionlist);print STDERR ("=> user linkage: $userlinkage\n")if$debug}if (@optionlist && $optionlist[0]=~ /^\W+$/ &&!($optionlist[0]eq '<>' && @optionlist > 0 && ref($optionlist[1]))){$prefix=shift (@optionlist);$prefix =~ s/(\W)/\\$1/g;$prefix="([" .$prefix ."])";print STDERR ("=> prefix=\"$prefix\"\n")if$debug}%opctl=();while (@optionlist){my$opt=shift (@optionlist);unless (defined($opt)){$error .= "Undefined argument in option spec\n";next}$opt=$+ if$opt =~ /^$prefix+(.*)$/s;if ($opt eq '<>'){if ((defined$userlinkage)&&!(@optionlist > 0 && ref($optionlist[0]))&& (exists$userlinkage->{$opt})&& ref($userlinkage->{$opt})){unshift (@optionlist,$userlinkage->{$opt})}unless (@optionlist > 0 && ref($optionlist[0])&& ref($optionlist[0])eq 'CODE'){$error .= "Option spec <> requires a reference to a subroutine\n";shift (@optionlist)if@optionlist && ref($optionlist[0]);next}$linkage{'<>'}=shift (@optionlist);next}my ($name,$orig)=ParseOptionSpec ($opt,\%opctl);unless (defined$name){$error .= $orig;shift (@optionlist)if@optionlist && ref($optionlist[0]);next}if (defined$userlinkage){unless (@optionlist > 0 && ref($optionlist[0])){if (exists$userlinkage->{$orig}&& ref($userlinkage->{$orig})){print STDERR ("=> found userlinkage for \"$orig\": ","$userlinkage->{$orig}\n")if$debug;unshift (@optionlist,$userlinkage->{$orig})}else {next}}}if (@optionlist > 0 && ref($optionlist[0])){print STDERR ("=> link \"$orig\" to $optionlist[0]\n")if$debug;my$rl=ref($linkage{$orig}=shift (@optionlist));if ($rl eq "ARRAY"){$opctl{$name}[CTL_DEST]=CTL_DEST_ARRAY}elsif ($rl eq "HASH"){$opctl{$name}[CTL_DEST]=CTL_DEST_HASH}elsif ($rl eq "SCALAR" || $rl eq "REF"){}elsif ($rl eq "CODE"){}else {$error .= "Invalid option linkage for \"$opt\"\n"}}else {my$ov=$orig;$ov =~ s/\W/_/g;if ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;")}elsif ($opctl{$name}[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;")}else {print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;")}}if ($opctl{$name}[CTL_TYPE]eq 'I' && ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY || $opctl{$name}[CTL_DEST]==CTL_DEST_HASH)){$error .= "Invalid option linkage for \"$opt\"\n"}}die ($error)if$error;$error=0;if (defined($auto_version)? $auto_version : ($requested_version >= 2.3203)){if (!defined($opctl{version})){$opctl{version}=['','version',0,CTL_DEST_CODE,undef];$linkage{version}=\&VersionMessage}$auto_version=1}if (defined($auto_help)? $auto_help : ($requested_version >= 2.3203)){if (!defined($opctl{help})&&!defined($opctl{'?'})){$opctl{help}=$opctl{'?'}=['','help',0,CTL_DEST_CODE,undef];$linkage{help}=\&HelpMessage}$auto_help=1}if ($debug){my ($arrow,$k,$v);$arrow="=> ";while (($k,$v)=each(%opctl)){print STDERR ($arrow,"\$opctl{$k} = $v ",OptCtl($v),"\n");$arrow="   "}}my$goon=1;while ($goon && @$argv > 0){$opt=shift (@$argv);print STDERR ("=> arg \"",$opt,"\"\n")if$debug;if (defined($opt)&& $opt eq $argend){push (@ret,$argend)if$passthrough;last}my$tryopt=$opt;my$found;my$key;my$arg;my$ctl;($found,$opt,$ctl,$arg,$key)=FindOption ($argv,$prefix,$argend,$opt,\%opctl);if ($found){next unless defined$opt;my$argcnt=0;while (defined$arg){print STDERR ("=> cname for \"$opt\" is ")if$debug;$opt=$ctl->[CTL_CNAME];print STDERR ("\"$ctl->[CTL_CNAME]\"\n")if$debug;if (defined$linkage{$opt}){print STDERR ("=> ref(\$L{$opt}) -> ",ref($linkage{$opt}),"\n")if$debug;if (ref($linkage{$opt})eq 'SCALAR' || ref($linkage{$opt})eq 'REF'){if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")if$debug;if (defined ${$linkage{$opt}}){${$linkage{$opt}}+= $arg}else {${$linkage{$opt}}=$arg}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to ARRAY\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}=[];print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to HASH\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}={};print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}else {print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")if$debug;${$linkage{$opt}}=$arg}}elsif (ref($linkage{$opt})eq 'ARRAY'){print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif (ref($linkage{$opt})eq 'HASH'){print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}elsif (ref($linkage{$opt})eq 'CODE'){print STDERR ("=> &L{$opt}(\"$opt\"",$ctl->[CTL_DEST]==CTL_DEST_HASH ? ", \"$key\"" : "",", \"$arg\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&{$linkage{$opt}}(Getopt::Long::CallBack->new (name=>$opt,ctl=>$ctl,opctl=>\%opctl,linkage=>\%linkage,prefix=>$prefix,),$ctl->[CTL_DEST]==CTL_DEST_HASH ? ($key): (),$arg)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("Invalid REF type \"",ref($linkage{$opt}),"\" in linkage\n");die("Getopt::Long -- internal error!\n")}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){if (defined$userlinkage->{$opt}){print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")if$debug;push (@{$userlinkage->{$opt}},$arg)}else {print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")if$debug;$userlinkage->{$opt}=[$arg]}}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){if (defined$userlinkage->{$opt}){print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")if$debug;$userlinkage->{$opt}->{$key}=$arg}else {print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")if$debug;$userlinkage->{$opt}={$key=>$arg}}}else {if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$L{$opt} += \"$arg\"\n")if$debug;if (defined$userlinkage->{$opt}){$userlinkage->{$opt}+= $arg}else {$userlinkage->{$opt}=$arg}}else {print STDERR ("=>\$L{$opt} = \"$arg\"\n")if$debug;$userlinkage->{$opt}=$arg}}$argcnt++;last if$argcnt >= $ctl->[CTL_AMAX]&& $ctl->[CTL_AMAX]!=-1;undef($arg);if ($argcnt < $ctl->[CTL_AMIN]){if (@$argv){if (ValidValue($ctl,$argv->[0],1,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}warn("Value \"$$argv[0]\" invalid for option $opt\n");$error++}else {warn("Insufficient arguments for option $opt\n");$error++}}if (@$argv && ValidValue($ctl,$argv->[0],0,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}}}elsif ($order==$PERMUTE){my$cb;if ((defined ($cb=$linkage{'<>'}))){print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&$cb($tryopt)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("=> saving \"$tryopt\" ","(not an option, may permute)\n")if$debug;push (@ret,$tryopt)}next}else {unshift (@$argv,$tryopt);return ($error==0)}}if (@ret && $order==$PERMUTE){print STDERR ("=> restoring \"",join('" "',@ret),"\"\n")if$debug;unshift (@$argv,@ret)}return ($error==0)}sub OptCtl ($) {my ($v)=@_;my@v=map {defined($_)? ($_): ("<undef>")}@$v;"[".join(",","\"$v[CTL_TYPE]\"","\"$v[CTL_CNAME]\"","\"$v[CTL_DEFAULT]\"",("\$","\@","\%","\&")[$v[CTL_DEST]|| 0],$v[CTL_AMIN]|| '',$v[CTL_AMAX]|| '',)."]"}sub ParseOptionSpec ($$) {my ($opt,$opctl)=@_;if ($opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x){return (undef,"Error in option spec: \"$opt\"\n")}my ($names,$spec)=($1,$2);$spec='' unless defined$spec;my$orig;my@names;if (defined$names){@names=split (/\|/,$names);$orig=$names[0]}else {@names=('');$orig=''}my$entry;if ($spec eq '' || $spec eq '+' || $spec eq '!'){$entry=[$spec,$orig,undef,CTL_DEST_SCALAR,0,0]}elsif ($spec =~ /^:(-?\d+|\+)([@%])?$/){my$def=$1;my$dest=$2;my$type=$def eq '+' ? 'I' : 'i';$dest ||='$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$entry=[$type,$orig,$def eq '+' ? undef : $def,$dest,0,1]}else {my ($mand,$type,$dest)=$spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;return (undef,"Cannot repeat while bundling: \"$opt\"\n")if$bundling && defined($4);my ($mi,$cm,$ma)=($5,$6,$7);return (undef,"{0} is useless in option spec: \"$opt\"\n")if defined($mi)&&!$mi &&!defined($ma)&&!defined($cm);$type='i' if$type eq 'n';$dest ||='$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$mi=$mand eq '=' ? 1 : 0 unless defined$mi;$mand=$mi ? '=' : ':';$ma=$mi ? $mi : 1 unless defined$ma || defined$cm;return (undef,"Max must be greater than zero in option spec: \"$opt\"\n")if defined($ma)&&!$ma;return (undef,"Max less than min in option spec: \"$opt\"\n")if defined($ma)&& $ma < $mi;$entry=[$type,$orig,undef,$dest,$mi,$ma||-1]}my$dups='';for (@names){$_=lc ($_)if$ignorecase > (($bundling && length($_)==1)? 1 : 0);if (exists$opctl->{$_}){$dups .= "Duplicate specification \"$opt\" for option \"$_\"\n"}if ($spec eq '!'){$opctl->{"no$_"}=$entry;$opctl->{"no-$_"}=$entry;$opctl->{$_}=[@$entry];$opctl->{$_}->[CTL_TYPE]=''}else {$opctl->{$_}=$entry}}if ($dups && $^W){for (split(/\n+/,$dups)){warn($_."\n")}}($names[0],$orig)}sub FindOption ($$$$$) {my ($argv,$prefix,$argend,$opt,$opctl)=@_;print STDERR ("=> find \"$opt\"\n")if$debug;return (0)unless defined($opt);return (0)unless$opt =~ /^($prefix)(.*)$/s;return (0)if$opt eq "-" &&!defined$opctl->{''};$opt=substr($opt,length($1));my$starter=$1;print STDERR ("=> split \"$starter\"+\"$opt\"\n")if$debug;my$optarg;my$rest;if (($starter=~/^$longprefix$/ || ($getopt_compat && ($bundling==0 || $bundling==2)))&& (my$oppos=index($opt,'=',1))> 0){my$optorg=$opt;$opt=substr($optorg,0,$oppos);$optarg=substr($optorg,$oppos + 1);print STDERR ("=> option \"",$opt,"\", optarg = \"$optarg\"\n")if$debug}my$tryopt=$opt;if ($bundling && $starter eq '-'){$tryopt=$ignorecase ? lc($opt): $opt;if ($bundling==2 && length($tryopt)> 1 && defined ($opctl->{$tryopt})){print STDERR ("=> $starter$tryopt overrides unbundling\n")if$debug}else {$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$rest=undef unless$rest ne ''}}elsif ($autoabbrev && $opt ne ""){my@names=sort(keys (%$opctl));$opt=lc ($opt)if$ignorecase;$tryopt=$opt;my$pat=quotemeta ($opt);my@hits=grep (/^$pat/,@names);print STDERR ("=> ",scalar(@hits)," hits (@hits) with \"$pat\" ","out of ",scalar(@names),"\n")if$debug;unless ((@hits <= 1)|| (grep ($_ eq $opt,@hits)==1)){my%hit;for (@hits){my$hit=$_;$hit=$opctl->{$hit}->[CTL_CNAME]if defined$opctl->{$hit}->[CTL_CNAME];$hit{$hit}=1}if (keys(%hit)==2){if ($auto_version && exists($hit{version})){delete$hit{version}}elsif ($auto_help && exists($hit{help})){delete$hit{help}}}unless (keys(%hit)==1){return (0)if$passthrough;warn ("Option ",$opt," is ambiguous (",join(", ",@hits),")\n");$error++;return (1,undef)}@hits=keys(%hit)}if (@hits==1 && $hits[0]ne $opt){$tryopt=$hits[0];$tryopt=lc ($tryopt)if$ignorecase;print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")if$debug}}elsif ($ignorecase){$tryopt=lc ($opt)}my$ctl=$opctl->{$tryopt};unless (defined$ctl){return (0)if$passthrough;if ($bundling==1 && length($starter)==1){$opt=substr($opt,0,1);unshift (@$argv,$starter.$rest)if defined$rest}if ($opt eq ""){warn ("Missing option after ",$starter,"\n")}else {warn ("Unknown option: ",$opt,"\n")}$error++;return (1,undef)}$opt=$tryopt;print STDERR ("=> found ",OptCtl($ctl)," for \"",$opt,"\"\n")if$debug;my$type=$ctl->[CTL_TYPE];my$arg;if ($type eq '' || $type eq '!' || $type eq '+'){if (defined$optarg){return (0)if$passthrough;warn ("Option ",$opt," does not take an argument\n");$error++;undef$opt}elsif ($type eq '' || $type eq '+'){$arg=1}else {$opt =~ s/^no-?//i;$arg=0}unshift (@$argv,$starter.$rest)if defined$rest;return (1,$opt,$ctl,$arg)}my$mand=$ctl->[CTL_AMIN];if ($gnu_compat && defined$optarg && $optarg eq ''){return (1,$opt,$ctl,$type eq 's' ? '' : 0);$optarg=0 unless$type eq 's'}if (defined$optarg ? ($optarg eq ''):!(defined$rest || @$argv > 0)){if ($mand){return (0)if$passthrough;warn ("Option ",$opt," requires an argument\n");$error++;return (1,undef)}if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}return (1,$opt,$ctl,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0)}$arg=(defined$rest ? $rest : (defined$optarg ? $optarg : shift (@$argv)));my$key;if ($ctl->[CTL_DEST]==CTL_DEST_HASH && defined$arg){($key,$arg)=($arg =~ /^([^=]*)=(.*)$/s)? ($1,$2): ($arg,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: ($mand ? undef : ($type eq 's' ? "" : 1)));if (!defined$arg){warn ("Option $opt, key \"$key\", requires a value\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}}my$key_valid=$ctl->[CTL_DEST]==CTL_DEST_HASH ? "[^=]+=" : "";if ($type eq 's'){return (1,$opt,$ctl,$arg,$key)if$mand;return (1,$opt,$ctl,$arg,$key)if$ctl->[CTL_DEST]==CTL_DEST_HASH;return (1,$opt,$ctl,$arg,$key)if defined$optarg || defined$rest;return (1,$opt,$ctl,$arg,$key)if$arg eq "-";if ($arg eq $argend || $arg =~ /^$prefix.+/){unshift (@$argv,$arg);$arg=''}}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/si){($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/si){$arg =~ tr/_//d;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (",$type eq 'o' ? "extended " : '',"number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}$arg=defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: 0}}}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/s){$arg =~ tr/_//d;($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/){$arg =~ tr/_//d}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (real number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);$arg=0.0}}}else {die("Getopt::Long internal error (Can't happen)\n")}return (1,$opt,$ctl,$arg,$key)}sub ValidValue ($$$$$) {my ($ctl,$arg,$mand,$argend,$prefix)=@_;if ($ctl->[CTL_DEST]==CTL_DEST_HASH){return 0 unless$arg =~ /[^=]+=(.*)/;$arg=$1}my$type=$ctl->[CTL_TYPE];if ($type eq 's'){return (1)if$mand;return (1)if$arg eq "-";return 0 if$arg eq $argend || $arg =~ /^$prefix.+/;return 1}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;return$arg =~ /^$o_valid$/si}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;return$arg =~ /^$o_valid$/}die("ValidValue: Cannot happen\n")}sub Configure (@) {my (@options)=@_;my$prevconfig=[$error,$debug,$major_version,$minor_version,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix ];if (ref($options[0])eq 'ARRAY'){($error,$debug,$major_version,$minor_version,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix)=@{shift(@options)}}my$opt;for$opt (@options){my$try=lc ($opt);my$action=1;if ($try =~ /^no_?(.*)$/s){$action=0;$try=$+}if (($try eq 'default' or $try eq 'defaults')&& $action){ConfigDefaults ()}elsif (($try eq 'posix_default' or $try eq 'posix_defaults')){local$ENV{POSIXLY_CORRECT};$ENV{POSIXLY_CORRECT}=1 if$action;ConfigDefaults ()}elsif ($try eq 'auto_abbrev' or $try eq 'autoabbrev'){$autoabbrev=$action}elsif ($try eq 'getopt_compat'){$getopt_compat=$action;$genprefix=$action ? "(--|-|\\+)" : "(--|-)"}elsif ($try eq 'gnu_getopt'){if ($action){$gnu_compat=1;$bundling=1;$getopt_compat=0;$genprefix="(--|-)";$order=$PERMUTE}}elsif ($try eq 'gnu_compat'){$gnu_compat=$action}elsif ($try =~ /^(auto_?)?version$/){$auto_version=$action}elsif ($try =~ /^(auto_?)?help$/){$auto_help=$action}elsif ($try eq 'ignorecase' or $try eq 'ignore_case'){$ignorecase=$action}elsif ($try eq 'ignorecase_always' or $try eq 'ignore_case_always'){$ignorecase=$action ? 2 : 0}elsif ($try eq 'bundling'){$bundling=$action}elsif ($try eq 'bundling_override'){$bundling=$action ? 2 : 0}elsif ($try eq 'require_order'){$order=$action ? $REQUIRE_ORDER : $PERMUTE}elsif ($try eq 'permute'){$order=$action ? $PERMUTE : $REQUIRE_ORDER}elsif ($try eq 'pass_through' or $try eq 'passthrough'){$passthrough=$action}elsif ($try =~ /^prefix=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .quotemeta($genprefix).")";eval {'' =~ /$genprefix/};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^prefix_pattern=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .$genprefix .")" unless$genprefix =~ /^\(.*\)$/;eval {'' =~ m"$genprefix"};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^long_prefix_pattern=(.+)$/ && $action){$longprefix=$1;$longprefix="(" .$longprefix .")" unless$longprefix =~ /^\(.*\)$/;eval {'' =~ m"$longprefix"};die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n")if $@}elsif ($try eq 'debug'){$debug=$action}else {die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")}}$prevconfig}sub config (@) {Configure (@_)}sub VersionMessage(@) {my$pa=setup_pa_args("version",@_);my$v=$main::VERSION;my$fh=$pa->{-output}|| ($pa->{-exitval}eq "NOEXIT" || $pa->{-exitval}< 2)? \*STDOUT : \*STDERR;print$fh (defined($pa->{-message})? $pa->{-message}: (),$0,defined$v ? " version $v" : (),"\n","(",__PACKAGE__,"::","GetOptions"," version ",defined($Getopt::Long::VERSION_STRING)? $Getopt::Long::VERSION_STRING : $VERSION,";"," Perl version ",$] >= 5.006 ? sprintf("%vd",$^V): $],")\n");exit($pa->{-exitval})unless$pa->{-exitval}eq "NOEXIT"}sub HelpMessage(@) {eval {require Pod::Usage;import Pod::Usage;1}|| die("Cannot provide help: cannot load Pod::Usage\n");pod2usage(setup_pa_args("help",@_))}sub setup_pa_args($@) {my$tag=shift;@_=()if @_==2 && $_[0]eq $tag;my$pa;if (@_ > 1){$pa={@_ }}else {$pa=shift || {}}if (UNIVERSAL::isa($pa,'HASH')){$pa->{-message}=$pa->{-msg};delete($pa->{-msg})}elsif ($pa =~ /^-?\d+$/){$pa={-exitval=>$pa }}else {$pa={-message=>$pa }}$pa->{-verbose}=0 unless exists($pa->{-verbose});$pa->{-exitval}=0 unless exists($pa->{-exitval});$pa}sub VERSION {$requested_version=$_[1];shift->SUPER::VERSION(@_)}package Getopt::Long::CallBack;sub new {my ($pkg,%atts)=@_;bless {%atts },$pkg}sub name {my$self=shift;''.$self->{name}}use overload '""'=>\&name,fallback=>1;1;
GETOPT_LONG

$fatpacked{"parent.pm"} = <<'PARENT';
  package parent;use strict;use vars qw($VERSION);$VERSION='0.225';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){if ($_ eq $inheritor){warn "Class '$inheritor' tried to inherit from itself\n"};s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}};"All your base are belong to us" 
PARENT

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

#!/usr/bin/env perl

use strict;
use warnings;
use App::mysqlenv::CLI;

App::mysqlenv::CLI->new->run;

__END__

=head1 NAME

mysqlenv - MySQL environment manager

=head1 SYNOPSIS

mysqlenv command syntax:

    mysqlenv <command> [options] [arguments]

Commands:

    # show usage
    mysqlenv help

    # list available mysql versions
    mysqlenv available

    # install mysql binary
    mysqlenv install 5.6.10

    # list installed mysqls
    mysqlenv list

    # execute command on current mysql
    mysqlenv exec mysql -uroot test -e '...'

    # change global default mysql to 5.1.68
    mysqlenv global 5.1.68

    # change local mysql to 5.5.30
    mysqlenv local 5.5.30

    # run this command after install, contains executable script.
    mysqlenv rehash

    # locate a program file in the mysql's path
    mysqlenv which mysqladmin

    # show current mysql version
    mysqlenv version

Generic command options:

    -h, --help      Shortcut of `mysqlenv help`.
    --version       Show mysqlenv version.

See C<< mysqlenv help >> for the full documentation of mysqlenv.

See C<< mysqlenv help <command> >> for detail description of the command.

=head1 DESCRIPTION

MySQL A-GO!GO!

=head1 INSTALLATION

=head2 1. Install your system

Run in your terminal the following:

  curl -kL http://bit.ly/mysqlenv | bash

or

  cpanm git://github.com/xaicron/mysqlenv.git
  mysqlenv self-install

=head2 2. Setup your shell

You should run the following:

  echo 'source ~/.mysqlenv/etc/bashrc' >> ~/.bashrc

B<< NOTE: >> if you using C<< zsh >> then modify your ~/.zshrc .

And restart your shell.

=head1 BUG REPORTING

Plese use github issues: L<< https://github.com/xaicron/mysqlenv/issues >>.

=head1 LICENSE

Copyright (C) xaicron.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 AUTHOR

xaicron E<lt>xaicron@gmail.comE<gt>

